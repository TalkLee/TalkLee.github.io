<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>行走在web路上</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="行走在web路上">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="行走在web路上">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="行走在web路上">
  
    <link rel="alternative" href="/atom.xml" title="行走在web路上" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  
<script type="text/javascript">

var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?a0f8b1403df03f16fcb98d796cec71de";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();

</script>

</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="F:/ghblog/favicon.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">TalkLee</a></h1>
		</hgroup>

		
		<p class="header-subtitle">写下不成熟的东西，才能看到成熟的希望</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/API探究/" style="font-size: 10px;">API探究</a> <a href="/tags/JavaScript-语法/" style="font-size: 10px;">JavaScript 语法</a> <a href="/tags/JavaScript语法/" style="font-size: 15px;">JavaScript语法</a> <a href="/tags/ejs/" style="font-size: 10px;">ejs</a> <a href="/tags/gulp/" style="font-size: 10px;">gulp</a> <a href="/tags/sass/" style="font-size: 10px;">sass</a> <a href="/tags/前端工具/" style="font-size: 10px;">前端工具</a> <a href="/tags/工作进度记录/" style="font-size: 10px;">工作进度记录</a> <a href="/tags/每日一博/" style="font-size: 20px;">每日一博</a> <a href="/tags/浏览器工作原理/" style="font-size: 10px;">浏览器工作原理</a> <a href="/tags/经典布局样式/" style="font-size: 10px;">经典布局样式</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">TalkLee</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="F:/ghblog/favicon.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">TalkLee</h1>
			</hgroup>
			
			<p class="header-subtitle">写下不成熟的东西，才能看到成熟的希望</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-循环添加下标到事件处理程序正确写法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/09/循环添加下标到事件处理程序正确写法/" class="article-date">
  	<time datetime="2016-05-09T04:53:46.000Z" itemprop="datePublished">2016-05-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/09/循环添加下标到事件处理程序正确写法/">循环添加下标到事件处理程序正确写法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>新手常犯错误,循环添加事件处理程序给一组元素，结果添加的对应数值为循环最大值</p>
<pre><code>&lt;p&gt;产品0&lt;/p&gt;
&lt;p&gt;产品1&lt;/p&gt;
&lt;p&gt;产品2&lt;/p&gt;
&lt;p&gt;产品3&lt;/p&gt;
</code></pre><p>JavaScript代码如下:</p>
<pre><code>var pTeam  = document.getElementsByTagName(&quot;p&quot;);
for(var i = 0; i &lt; pTeam.length ; i++){
    pTeam[i].onclick = function() {
        alert(i);   //点击任意p标签均返回4
    }
}
</code></pre><p>原因:循环时相应函数并未保存i，而是最后一次的值</p>
<p>解决方法:</p>
<p>1.变量保存到元素属性中</p>
<pre><code>for(var i = 0 ; i &lt; pTeam.length ; i++){
    pTeam[i].i = i;   //保存下标到p元素属性i内
    pTeam[i].onclick = function () {
        alert(this.i);   //this此时指向p元素,所以this.i表示访问p元素的i属性
    }
}
</code></pre><p>2.访问事件处理程序调用函数中的i</p>
<pre><code>for(var i = 0 ; i &lt; pTeam.length ; i++ ){
    (pTeam[i].onclick = function(){
        alert(arguments.callee.i);
    }).i = i ;   //后面这句没看懂...
}
</code></pre><p>3.利用闭包，立即执行函数表达式传入下标作为参数，内部事件处理程序根据作用域链找到传入的下标</p>
<pre><code>for(var i = 0 ; i &lt; pTeam.length ; i++){
    (function(arg){
        var j = 10;
        pTeam[i].onclick = function () {
            alert(j);
            alert(arg);
        }
    })(i);  //立即调用函数表达式传入下标作为参数,内部函数根据作用域链找到外部作用于中函数的值
}
</code></pre><p>4.同样利用闭包，该方法保存下标到外部函数中作为局部变量，根据作用域链找到下标</p>
<pre><code>for(var i = 0 ; i &lt; pTeam.length ; i++){
    (function(arg){
        var temp = i;  //外部函数保存下标，内部函数根据作用域链获取外部函数中保存的下标
        pTeam[i].onclick = function () {
            alert(temp);
        }
    })();
}
</code></pre><p>5.闭包，返回响应函数，外部函数中下标作为参数</p>
<pre><code>for(var i = 0 ; i &lt; pTeam.length ; i++){
    pTeam[i].onclick = function(arg){
        return function() {  //返回响应函数，其中由于闭包获取外部函数传递的下标作为参数
            alert(arg);
        }
    }(i);
}
</code></pre><p>6.函数构造函数生成函数实例，传入下标(没看懂)</p>
<pre><code>for(var i = 0; i &lt; pTeam.length ; i++){
    pTeam[i].onclick = new Function(&quot;alert(&quot; + i + &quot;);&quot; );
}
</code></pre><p>7.asd </p>
<pre><code>for(var i = 0 ; i &lt; pTeam.length ; i++) {
    pTeam[i].onclick = Function(&apos;alert(&apos; + i + &apos;)&apos;);
}
</code></pre><p>背景知识:</p>
<p>构造函数生成函数实例语法如下:</p>
<pre><code>new Function(param1,param2,.....functionBody)
</code></pre><p>其中，param1,param2….均为传入函数的参数，最后一个参数functionBody为函数体，所有传入的参数均为字符串形式。该种方法声明的函数为匿名函数，所以需要定义变量保存函数的引用</p>
<p>Function定义函数表达式:</p>
<p>允许开发者动态创建函数<br>每次调用Function构造函数都会解析一次函数体，并创建新的函数对象。不像嵌套函数(递归调用函数?)以后函数定义表达式只编译一次<br>Function创造的函数处于全局作用域中</p>
<p>自行比较:</p>
<pre><code>var a= 10;
function test(){
    var a = 0;
    return new Function(&quot;alert(&quot; + &quot;a&quot; + &quot;);&quot;);  //弹出10
}
test()();


var a= 10;
function test(){
    var a = 0;
    return new Function(&quot;alert(&quot; + a + &quot;);&quot;);  //弹出0
}
test()();
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hexo命令" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/08/hexo命令/" class="article-date">
  	<time datetime="2016-05-08T13:53:47.000Z" itemprop="datePublished">2016-05-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/08/hexo命令/">hexo常用命令</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hexo 常用命令</p>
<p>hexo init [folder]  //生成hexo博客</p>
<p>hexo new [layout] <title>  //生成新的静态页面,layout默认使用 _config.yml.</title></p>
<p>hexo generate  //生成静态文件</p>
<p>hexo server //运行服务器，默认4000为端口号</p>
<p>hexo deploy //部署到远程站点</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-匿名函数的调用方式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/07/匿名函数的调用方式/" class="article-date">
  	<time datetime="2016-05-07T14:39:56.000Z" itemprop="datePublished">2016-05-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/07/匿名函数的调用方式/">匿名函数的多种调用方式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>预备知识:</p>
<p>立即执行函数表达式:</p>
<p>正常来说,函数声明一般通过声明具名函数或者通过匿名函数传递引用给变量。<br>从调用来讲，都是函数名(引用)后加()进行调用。</p>
<pre><code>function f(){
    console.log(&apos;f&apos;);
};
var ff = function() {
    console.log(&apos;ff&apos;);
};
f();  //通过()调用函数
</code></pre><p>function (){ …}();  // SyntaxError: Unexpected token (  </p>
<p>原因:<br>    javascript解释器会将遇到的function语句看作函数声明语句,而函数声明语句中function后跟函数名，而左括号无法对函数命名，所以就出现了以上的错误。</p>
<p>###而匿名函数调用方法1 2 通过()实现了立即执行(匿名)函数表达式</p>
<p>()运算符:</p>
<pre><code>JavaScript会将()中内容看作表达式,
而()操作符的用法如下所示:

(1);
(function(){...})  === function(){...}   

传入()的函数声明经过括号运算符会直接返回该函数(名或者说引用)，此时，上式变为 anonymousFunction(),即为函数普通的调用方式。
</code></pre><p>, 运算符: </p>
<p>例： (1,2,3,alert)(“Amazing”);  </p>
<pre><code>多个表达式可以用逗号分开，其中用逗号分开的表达式的值分别结算，但整个表达式的值是最后一个表达式的值。
</code></pre><p>上式返回alert(‘Amazing’);</p>
<p>考察题目:</p>
<pre><code>// 如果本身就是expression，那么根本不需要做任何处理
var i = function(){ return 10; }();
true &amp;&amp; function(){ /* code */ }();
0, function(){ /* code */ }();

// 如果你不在乎返回值，可以这么做
!function(){ /* code */ }();
~function(){ /* code */ }();
-function(){ /* code */ }();
+function(){ /* code */ }();

上述语法无误，原因在于函数声明在语句内部，即为函数表达式，而并非函数声明语句.
</code></pre><p>引例:</p>
<p>[1,2,3][1] ;  左式返回2<br>[1,2,3][1,2]; 左式返回3</p>
<p>立即执行函数表达式用途:</p>
<ol>
<li>模拟块作用域，防止全局变量命名冲突</li>
<li>闭包问题</li>
<li>模拟单例</li>
</ol>
<p>// 会输出10个10，而不是预期的0 1 2 3 4 5 6 7 8 9<br>var res = f1();<br>for(var i = 0; i &lt; res.length; i++) {<br>    res<a href="">i</a>;<br>}</p>
<p>匿名函数调用方法:</p>
<p> 方法1：</p>
<pre><code>var method1 = (function(x,y) {
    alert(x+y);
    return x+y;
}(3,4));
//括号包裹函数的执行，返回函数处理结果
</code></pre><p>方法2:</p>
<pre><code>var method2 = (function(x,y){
    alert(x+y);
    return x+y;
})(3,4);
//返回一个引用，得到返回值
</code></pre><p>方法3:</p>
<pre><code>void function(x){  //void后面跟表达式，所以此时函数声明变为立即执行函数调用
    x =  x-1;
    alert(x);
}(9);
</code></pre><p>void操作符:</p>
<p>引例:</p>
<pre><code>typeof void 0   //undefined
</code></pre><p>介绍: 一元表达式,执行过程:</p>
<pre><code>- 令expr为解释执行后面表达式的结果
- 调用getValue(expr)
- 返回undefined
</code></pre><p>(是不是很蛋疼。。。明明直接返回undefined，还要执行getValue)</p>
<p>getValue(expr)中expr有可能先执行导致对数据产生影响，即使返回了undefined，仍然是有一定副作用的</p>
<p>####即无论void后面表达式是什么，都返回undefined</p>
<p>用void的原因在于:<br>    undefined并不是JavaScript保留字，所以可以用undefined来命名变量，也就是undefined可以是任何类型变量的名字，一旦被用来命名<br>而void一定返回undefined值，无论此时上下文的undefined是什么。</p>
<p>void另一用途:<br>    填写a标签的href属性来阻止点击链接的默认跳转写法如下:</p>
<pre><code>&lt;a href=&quot;javascript:void(0)&quot;&gt;   //即返回undefined来阻止链接点击的默认事件:跳转
</code></pre><p>疑似img标签的src属性也可按照此种方法</p>
<p>方法4:</p>
<pre><code>-function(x,y){
    alert(x+y);
    return x+y;
}(3,4);

+function(x,y){
    alert(x+y);
    return x+y;
}(3,4);

--function(x,y){
    alert(x+y);
    return x+y;
}(3,4);

++function(x,y){
    alert(x+y);
    return x+y;
}(3,4);    
~function(x, y) {
    alert(x+y);
   return x+y;
}(3, 4);

原因类似void,导致后面的函数声明变为函数表达式
</code></pre><p>方法5：</p>
<pre><code>typeof function(){
    console.log(this);  
}(this)
//理由同上
</code></pre><p>方法6:</p>
<pre><code>delete function(){
   console.log(this) // 浏览器得控制台输出window
}(this)
//同上
</code></pre><p>方法7:</p>
<pre><code>new function(win){
   console.log(win) // window
}(this)
</code></pre><p>方法8：</p>
<pre><code>new function(){
    console.log(this) // 这里的this就不是window了
}
</code></pre><p>方法9:</p>
<pre><code>1, function(){
    console.log(this) // window
}();
</code></pre><p>方法10:</p>
<pre><code>1^function(){
    console.log(this) // window
}();
</code></pre><p>方法11:</p>
<pre><code>1&gt;function(){
    console.log(this) // window
}();
</code></pre><p>总结:<br>    这篇博文写的挺烂的，有点标题党的感觉，<br>    其实绝大多数方法考察的并不是匿名函数方面的，而是JS的一些不常用或者说不容易注意的知识点。算是奇技淫巧的一种吧</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-git-study-from-a-freshman" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/06/git-study-from-a-freshman/" class="article-date">
  	<time datetime="2016-05-06T15:29:25.000Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/git-study-from-a-freshman/">git study from a freshman</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 本笔记是学习廖雪峰前辈的git教程过程中所写的总结。</p>
<p>mkdir：创建目录</p>
<p>一、创建版本库(仓库:repository)</p>
<p>用于创建可供git跟踪修改的目录。该目录下的所有文件均可被跟踪文件历史，修改文件。</p>
<p>1.mkdir(若在已有目录下创建版本库，省略这步)</p>
<p>2.git init初始化版本库</p>
<p>二、添加已有文件到版本库</p>
<p>版本控制系统只能跟踪记录文本文件的内容变化，二进制文件无法跟踪内容变化。</p>
<p>1.git add 把文件添加到版本库,多个文件名之间空格隔开</p>
<p>2.git commit 把之前添加的文件提交到版本库</p>
<p>git commit 后可以(推荐)添加本次提交的说明</p>
<p>语法如下：</p>
<p>git commit -m “description”</p>
<p>三、跟踪文件的修改(文件被修改以后应该被确认没有错误后方能提交)</p>
<p>显示仓库状态 git status（查看有无修改）</p>
<p>显示文件的修改情况 git diff filename(包括后缀)</p>
<p>四、提交修改：与提交新文件的步骤类似</p>
<p>先 add 被修改的文件到工作区，然后 commit 。</p>
<p>当所有被修改文件重新提交后，重新检查版本库状态发现无文件需要提交，且工作目录干净。</p>
<p>五、版本回退(git版本号采用SHA1算法生成)</p>
<p>显示版本日志 git log：  （逆序显示,从最近版本开始显示）</p>
<p>后加 –pretty=oneline    显示简略版本日志</p>
<p>版本回退 git reset –hard HEAD + 后缀 , 其中HEAD表示当前版本, 后缀有两种写法：</p>
<p>1.^…..^ 几个”^”表示向前回退多少个版本</p>
<p>2.~num num表示向前回退的版本数</p>
<p>版本回退还可以在hard后填写具体版本号以回到具体某个版本(在关闭命令行之前，其他版本都是存在的，只是回退到前面的版本后，后面的版本对于版本日志显示是不可见的 )</p>
<p>例：git reset –hard 3268164(git会自动根据填写的版本号寻找对应版本，所以不用完全填写)</p>
<p>版本回退是通过指向当前版本的HEAD指针实现的，将HEAD指针移动到哪个版本，就可以回退到哪个版本</p>
<p>git reflog 记录了版本修改历史（不同于log命令的是，版本回退会导致当前版本之后提交的版本仍然存在但是在log命令下无法显示，reflog可以记录每次提交产生的版本修改记录，无论当前版本是哪个）</p>
<p>每行第一个字符串即为该版本的commit id(提交时候生成的id)</p>
<p>通过该命令获取到版本号后，即可利用git reset –hard命令随意回退修改文件版本</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-html5-tag-review" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/06/html5-tag-review/" class="article-date">
  	<time datetime="2016-05-06T15:28:20.000Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/html5-tag-review/">html5_tag review</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>标签：</p>
<p>section：适用于独立结构内容，无结构关系(例如article，aside与其他标签可以组合形成具有特定结构关系的标签结构）。须具有标题（待考证）.</p>
<p>menu&amp;nav:menu用于应用程序的菜单，而nav用于导航，体现在语义意义上。</p>
<p>aside：附属信息，例如：引用，侧边栏，广告等等，区别于父元素主体内容的意义迥异的内容。</p>
<p>time：pubdate：布尔类型，用于指明多个time标签中哪个time用于表示发布时间。</p>
<p>header：表示某个内容块的标题（可以为复合标题，例如包括搜索表单，logo图片等）</p>
<p>footer：父元素的脚注（作者，版权信息等）</p>
<p>hgroup：标签组合</p>
<p>pubdate：布尔类型</p>
<p>HTML5及之前版本标签用法及语义学习：</p>
<p>根标签：</p>
<p>html：根元素，代表HTML文档的根节点。所有其它元素都是它的子节点。</p>
<p>元标签（包含一些文本自身的信息）:</p>
<p>head：其中规定文档的标题，脚本样式的链接。</p>
<p>title：文档的标题。</p>
<p>base：定义相对URL的基准。</p>
<p>link：链接外部样式表到html文档</p>
<p>meta：定义其它元标签无法描述的元信息。（知识点小技巧较多，以后展开学习）</p>
<p>stlye：内联样式表。</p>
<p>脚本相关：</p>
<p>script：链接外部脚本</p>
<p>noscript：禁止脚本运行时显示的替代内容</p>
<p>template（模板）：允许包含加载页面时不渲染，之后通过JS实例化的内容。存储在页面中通过JS来操作的内容。（未使用过）</p>
<p>章节：</p>
<p>body：表示文档的内容</p>
<p>section：表示一个区域（无结构信息，例如表示导航，侧边栏，正文等），在文档中框架中充当一定作用，而非一般容器div。一般包含一个heading。</p>
<p>nav：导航</p>
<p>article:相对独立的内容部分</p>
<p>aside：侧边栏</p>
<p>hN：文旦标题，描述部分内容的主题</p>
<p>header：页面或部分内容头部，经常包含logo，标题，导航目录</p>
<p>footer：页面或部分内容尾部，经常包含法律信息、版权、反馈信息等。</p>
<p>address：为最近的article标签提供联系信息（作者信息），或者为body提供联系信息。不能 用于其他用途。</p>
<p>main：定义文档主要的唯一内容。</p>
<p>组织内容：</p>
<p>p：段落</p>
<p>hr：章节、文章中段落之间的分隔符。</p>
<p>pre：已排版内容，提示浏览器保留内容原始格式。</p>
<p>blockquote：引用其他的内容。</p>
<p>ol：有序列表</p>
<p>ul：无序列表</p>
<p>li：列表项</p>
<p>dl（defined list）：定义列表</p>
<p>dt（defined term）：定义的名称。</p>
<p>dd（defined description）：定义的描述。</p>
<p>figure：与文档有关的图例及其说明，可不包含figcaption，表示没有说明。</p>
<p>figcaption：对figure中的图的描述文字</p>
<p>div：：通用容器，用于样式描述的需求将标签进行分组。</p>
<p>文字形式：</p>
<p>a：超链接</p>
<p>em：强调，文字以斜体形式出现。</p>
<p>strong：重点，文字以粗体形式出现，体现内容在上下文中的重要性。</p>
<p>small：注释，用于法律申明等，文字以比正常文字小的字号出现。</p>
<p>s：不准确或不相关的内容，内容呈现文本删除线或一条线穿过。</p>
<p>cite：作品的引用，缩写或者名称。</p>
<p>q：内联形式的简短引用。</p>
<p>dfn：定义</p>
<p>abbr：缩写，完整内容出现在其title属性中</p>
<p>data：机器可读形式的内容</p>
<p>time：表示日期和时间，其机器可读形式通过datetime形式表示</p>
<p>code：代码</p>
<p>var：代码变量</p>
<p>samp：程序输出</p>
<p>kdd：用户（键盘）输入，在浏览器中以等宽字体的内联元素显示。</p>
<p>sub：下标</p>
<p>sup：上标</p>
<p>i：某种原因区别于普通文本的文本，以斜体显示。</p>
<p>b：仅表示与普通文本有字体上的区别，无语义，表关键字等，以加粗形式显示。</p>
<p>u：文字以下划线形式表示，如标记拼写错误文字。</p>
<p>mark：表示内容在上下文中的关联。区别于strong。</p>
<p>ruby：被ruby注释标记的文字</p>
<p>rt：ruby注释</p>
<p>rp：代表 ruby 注释两边的 额外插入文本 ，用于在不支持 ruby 注释显示的浏览器中提供友好的注释显示。</p>
<p>bdi：不同于父元素文本方向的文字</p>
<p>bdo：指定子元素文本方向。</p>
<p>span：没有特殊含义的文本，语义元素不合适时使用该元素</p>
<p>br：换行</p>
<p>wbr：建议换行</p>
<p>编辑：</p>
<p>ins：增加到文档中的内容</p>
<p>del：从正文中移出的内容。</p>
<p>嵌入内容</p>
<p>img：图片</p>
<p>iframe：框架</p>
<p>embed：应用程序</p>
<p>object：</p>
<p>param：object指定的插件的参数</p>
<p>video：视频，提供用户界面</p>
<p>audio：音频</p>
<p>source：指定video或audio的媒体源</p>
<p>track：指定video或audio的字幕或歌词</p>
<p>canvas：位图区域</p>
<p>map，area：共同定义图像映射区域</p>
<p>svg：外链矢量图</p>
<p>math：数学公式</p>
<p>表格</p>
<p>table：表</p>
<p>caption：表的标题</p>
<p>colgroup：列组</p>
<p>col：列</p>
<p>tbody：表格主体</p>
<p>thead：表头</p>
<p>tfoot：表尾</p>
<p>tr：行</p>
<p>td：表的正文单元格</p>
<p>th：头部单元格</p>
<p>表单：</p>
<p>form：表单包含多个控件</p>
<p>fieldset：控件组</p>
<p>legend：fieldset的标题</p>
<p>label：表单控件的标题</p>
<p>input：文本框、单选框等控件，通过type选择</p>
<p>button：按钮</p>
<p>select：下拉框</p>
<p>datalist：包含一组option，表示可选项</p>
<p>optgroup：select中创建多个分组的选项</p>
<p>textarea：多行文本框</p>
<p>keygen：秘钥对生成器控件</p>
<p>output：计算结果，输出</p>
<p>progress：进度条</p>
<p>meter：滑动块</p>
<p>交互元素（待学习）</p>
<p>details </p>
<p>summary</p>
<p>menuitem</p>
<p>menu</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Apache-install" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/06/Apache-install/" class="article-date">
  	<time datetime="2016-05-06T15:22:39.000Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/Apache-install/">Apache_install</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>记录安装Apache的流程，没有进行详细配置，只是记录搭建服务器的流程用于学习Ajax等知识，方便以后重新安装，不用每次都翻别人博客学习安装了，大神看到这里可以关掉这个粗糙简陋的博文了。</p>
<ol>
<li>官网上找到download链接，选择用于microsoft的链接，在第三方网站下载Apache的解压包</li>
</ol>
<p>2.解压在任意目录下</p>
<p>3.进入Apache安装目录下的bin目录，然后尝试http.exe，弹出Apache sever的请求运行的弹窗，网页进入localhost，可以看到Apache的服务器运行的成功反馈</p>
<p>4.http –k install  安装Apache服务，之后可以通过http –k start 启动Apache服务</p>
<p>其他命令:</p>
<ul>
<li>httpd -k stop  停止Apache服务</li>
<li>httpd -k restart 重启</li>
<li>httpd -k uninstall 卸载Apache服务</li>
<li>httpd -v 查看版本</li>
<li>httpd -h 帮助菜单</li>
</ul>
<p>5.在系统环境变量Path后添加Apache文件中的bin目录，以后就可以直接httpd –k start 启动Apache服务器了（是httpd不是http）</p>
<p>报错解决办法：</p>
<p>Errors reported here must be corrected before the service can be started.</p>
<p> ServerRoot must be a valid directory</p>
<p>表示Apache根目录无效，因为Apache的配置文件httpd.conf 中 对于根目录默认填写的是Apache+版本号（猜测，当前时间显示的是 Apache24），</p>
<p>故如果解压Apache文件夹后，如果修改了Apache的文件名就会报错</p>
<p>解决：进入httpd.conf修改提示错误的行里的根目录信息即可修复该问题。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-4-8-study" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/06/4-8-study/" class="article-date">
  	<time datetime="2016-05-06T15:21:01.000Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/4-8-study/">4.8 study</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>   var arr = [];
1. arr[push](123);  ×
2. arr[&quot;push&quot;](123); √
</code></pre><p>第一种写法：将push方法看做了变量</p>
<p>2.typeof会误将值为null的变量指示为Object，但实际上null不是Object</p>
<p>3.条件判断语句中对象被认为是true</p>
<pre><code>var func = function(arg1,arg2,arg3,arg4,arg5){};
func.length = 5;     
</code></pre><p>函数期望参数的个数保存在其length属性中，而argments数组的长度则是实参个数</p>
<p>5.函数作用域中有this对象代表调用该函数的对象.<br>函数作为方法被调用时，默认this值等于该对象。</p>
<p>6.call方法中第一个参数指定this的值，其他参数传给调用call方法的函数作为其参数进行调用</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="extract-dark-time" class="article article-type-extract" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/06/dark-time/" class="article-date">
  	<time datetime="2016-05-06T15:18:40.000Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/dark-time/">&#39;dark-time&#39;</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>专注一件事，给予最高优先级 (对于整个生活而言),空闲时间思考、消化阅读的东西.</p>
<p>迅速进入状态，保持专注状态</p>
<p>规划时间，对进度有清晰的界定</p>
<p>反思自己，找出问题，制定规划，解决问题</p>
<p>尽快作出决定，保持大方向正确，逐步修正方向</p>
<p>主动回顾旧知识，做笔记</p>
<p>要事第一，长远积累有助于人生的事</p>
<p>写下不成熟的东西，才能看到成熟的希望</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-objectEqual" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/06/objectEqual/" class="article-date">
  	<time datetime="2016-05-06T13:03:59.000Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/objectEqual/">objectEqual</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###JS对象的比较</p>
<p>背景知识：</p>
<p>####==运算符规则：</p>
<p>相比较===,==运算符可能会将操作数转化后作比较</p>
<p>归纳如下：</p>
<ol>
<li>存在布尔值，即转化为数字值</li>
<li>一个数字一个字符串，字符串转化为数字</li>
<li>一个对象一个非对象，对象转化为基本值( 调用vlaueOf()方法 )，然后使用前面规则做比较</li>
<li>两操作数均为对象,比较是否为指向同一对象的引用<br>即数字为最高级，布尔值和字符串为同一等级，对象等级最低，操作数从低级到高级转化</li>
</ol>
<p>其他规则：</p>
<ul>
<li>null == undefined，</li>
<li>NaN和任何都不相同</li>
<li>null和undefined在与其他作比较时，不做转化</li>
</ul>
<p>####valueOf方法:</p>
<p>valueOf通常和toString方法返回值相同</p>
<p>以下讨论<strong>toString</strong>方法：</p>
<p>数组 –&gt; 字符串，与数组调用无参数join方法结果相同<br>逻辑内置对象 –&gt; 字符串，逻辑真变true，假变false<br>Date内置对象 –&gt; 字符串，使用本地时间表示<br>数字内置对象 –&gt; 字符串，参数为表示转化基数，默认为10 </p>
<pre><code>(155).toString(2)  =&gt; &apos;10011011&apos;
</code></pre><p>对象字面量或者对象构造函数生成的对象，返回 <strong>[object Object]</strong><br>函数对象返回函数定义(包括函数体)字符串</p>
<p>####typeof运算符:<br>基本类型返回值:<br>null,undefined,number,string,boolean<br>对象类型：<br>object，function<br>所以，typeof只能检测基本类型值，对于对象类型无法判断是哪类Object</p>
<p>代码分析如下:</p>
<p>1.存在BUG,Function也继承该方法，但是未考虑function的比较，所以是狭义上的object<br>2.没看懂function里面的两个if语句，之后再看</p>
<pre><code>//添加方法给对象原型,所以比较变量必定为对象
Object.prototype.userEqual = function(obj){
    if(this == obj){  
        //假设obj指向this指向的对象,方法调用中判断this指向对象和参数对象是否指向同一对象
        return true;

    }
    //排除undefined和null两个基本类型以及其他基本类型和function类型
    else if( typeof(obj)== &apos;undefined&apos; || obj == null || typeof(obj) !=&apos;object&apos; ){ 
        return false;
    }
    //以下情况为obj为对象，但是并非引用同一对象，所以需要比较内部属性
    var length = 0 ; var length1 = 0;
    var ele;
    for(ele in this){
        length++;
    }
    for(ele in obj){
        length1++;
    }
    //属性长度是否一致
    if(length!= length){
        return false;
    }
    //为同一构造函数生成
    if(obj.constructor == this.constructor){
        for( ele in this){
            //如果属性为对象，需要this指向的对象和obj对象同名的属性对象递归比较
            if(typeof(this[ele]) == &apos;object&apos;){
                if(!this[ele].userEqual(obj[ele])){}
                return false;
            }
            else if(typeof(this[ele]==&apos;function&apos;)){
                //两个函数等价,toString方法将函数转化为字符串进行比较
                if(!this[ele].toString().userEqual(obj[ele].toString() ) )
                {
                    return false;
                }
                else if(this[ele]!=obj[ele]){
                    return false;
                }
                return true;
            }
            return false;
        }
    }
};
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 TalkLee
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>