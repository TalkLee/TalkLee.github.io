<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>行走在web路上</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="行走在web路上">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="行走在web路上">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="行走在web路上">
  
    <link rel="alternative" href="/atom.xml" title="行走在web路上" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  
<script type="text/javascript">

var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?a0f8b1403df03f16fcb98d796cec71de";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();

</script>

</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="F:/ghblog/favicon.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">TalkLee</a></h1>
		</hgroup>

		
		<p class="header-subtitle">写下不成熟的东西，才能看到成熟的希望</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/API探究/" style="font-size: 10px;">API探究</a> <a href="/tags/JavaScript-语法/" style="font-size: 10px;">JavaScript 语法</a> <a href="/tags/JavaScript语法/" style="font-size: 15px;">JavaScript语法</a> <a href="/tags/ejs/" style="font-size: 10px;">ejs</a> <a href="/tags/gulp/" style="font-size: 10px;">gulp</a> <a href="/tags/sass/" style="font-size: 10px;">sass</a> <a href="/tags/前端工具/" style="font-size: 10px;">前端工具</a> <a href="/tags/工作进度记录/" style="font-size: 10px;">工作进度记录</a> <a href="/tags/每日一博/" style="font-size: 20px;">每日一博</a> <a href="/tags/浏览器工作原理/" style="font-size: 10px;">浏览器工作原理</a> <a href="/tags/经典布局样式/" style="font-size: 10px;">经典布局样式</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">TalkLee</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="F:/ghblog/favicon.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">TalkLee</h1>
			</hgroup>
			
			<p class="header-subtitle">写下不成熟的东西，才能看到成熟的希望</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-trim" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/21/trim/" class="article-date">
  	<time datetime="2016-09-21T00:02:07.540Z" itemprop="datePublished">2016-09-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="trim方法实现"><a href="#trim方法实现" class="headerlink" title="trim方法实现:"></a>trim方法实现:</h2><p>背景知识：<br>trim指去除字符串首尾的空白符(空格、制表符等)</p>
<p>字符串(对象)的方法：</p>
<p>1.获取字符串指定位置字符</p>
<pre><code>var str1 = &apos;hello&apos;;
console.log(str1.charAt(1));
</code></pre><p>2.获取字符串指定位置字符的编码</p>
<pre><code>var str1 = &apos;hello &apos;;
var str2 = &apos;world&apos;;
console.log(str1.charAt(1)); //e
</code></pre><p>3.下表法访问指定位置字符(ECMAscript5标准)<br>        var str1 = ‘hello ‘;<br>        var str2 = ‘world’;<br>        console.log(str1[1]);  //e</p>
<p>操作方法：</p>
<p>1.拼接：concat(),返回拼接好的字符串</p>
<pre><code>var str1 = &apos;hello &apos;;
var str2 = &apos;world&apos;;
var concatedStr = str1.concat(str2);
console.log(concatedStr); // hello world
</code></pre><p>2.截取字符串，返回值为截取获的的子字符串</p>
<p>2-1.slice:<br>    参数一指开始位置，参数二指结束位置的后一个字符</p>
<pre><code>var str1 = &apos;hello &apos;;
var str2 = &apos;world&apos;;
console.log(str1.slice(1,3));  //el   
</code></pre><p>2-2. substr()</p>
<p>替换方法：</p>
<p>// 待补充String的基本方法</p>
<p>RegExp对象:</p>
<p>创建正则表达式:</p>
<ol>
<li>var reg1 = /pattern/flag;</li>
<li>var reg2 = new RegExp(“pattern”,flag);  //flag此时为字符串</li>
<li>var reg3 = new RegExp(/pattern/,flag);  //flag此时为字符串</li>
</ol>
<p>例：</p>
<pre><code>var reg = new RegExp(&apos;abc&apos;,&apos;gi&apos;);  
var reg = /abc/gi;
两者等价,即构造函数中无需添加pattern两边的/
</code></pre><p>构造函数生成正则的优点在于正则表达式动态变化的情况下可以传入变量</p>
<p><a href="http://www.w3school.com.cn/js/js_special_characters.asp" target="_blank" rel="external">向字符串中加入特殊字符,需要转义</a>，即加入反斜杠 <strong>\ </strong></p>
<p>字符转义:正则表达式中的元字符需要进行转义才能表示字面含义</p>
<p>元字符:</p>
<ul>
<li>\b 单词的分界处 , 匹配位置</li>
<li>. 除了 <strong>换行符</strong> 的任意 <strong>字符</strong></li>
<li>\d 匹配数字</li>
<li>\s 匹配任意空白符(空格制表符换行符换页符中英文全角半角空格等)</li>
<li>\w 匹配字母数字下划线</li>
<li>^ 匹配字符串的开始,匹配位置</li>
<li>$ 匹配字符串的结束,匹配位置</li>
<li>( 和 )</li>
</ul>
<p>当在正则表达式中添加元字符时，需要进行转义<br>当在构造函数的模式参数中添加元字符时，需要进行双重转义<br>例：</p>
<pre><code>//?在正则中表示非字面含义，若要表示字面含义，需通过\进行转义
var reg = /\?/;  
var reg2 = new RegExp(&quot;\?&quot;); 在正则表达式构造函数参数字符串中正则表达式的量词都是需要被转义的特殊字符，所以\?实际表达含义为 &apos;?&apos; 
//若要reg2表示含义和reg相同，需要对\做转义
var reg3 = new RegExp(&quot;\\?&quot;);// \\表示后一个\被转义了，浏览器会看作字符串\?,等价于reg3 = /\?/ 
</code></pre><p>动态属性:<br>    lastIndex : 下次匹配开始的位置,可以被exec方法修改，可写<br>    ignoreCase:是否包含标志i<br>    global:是否包含标志g<br>    multiline:是否包含标志m<br>    source：正则表达式定义时模式字符串,与reg.toString()结果相同，包含斜杠和标志</p>
<p>静态属性:</p>
<pre><code>- input用于匹配的母串，当调用test和exect方法成功匹配后input属性被会自动修改为上次匹配的字符串
- lastMatch 最后一次匹配成功的子串
- lastParen 最后分配的分组号
- leftContext 被查找字符串从字符串开始到最后匹配的位置之间的字符串
- rightContext 被查找的字符串中从最后一个匹配位置开始到字符串结尾的字符串(不包括最后一个匹配位置后一个位置)
- 
</code></pre><p>实例方法:</p>
<ol>
<li>exec()<br>param：String<br>返回包含该查找结果的一个数组,无匹配时返回null<br>数组第一个元素为匹配的子串,剩余元素保存被匹配的正则的各个分组<br>还包含其他属性:被匹配的<br>index:匹配到的子串首字母在母串中的位置<br>input:原始字符串(母串)<br>同时在比较过后，正则表达式的lastIndex属性也随之更新</li>
</ol>
<ol>
<li>test()<br>param1:String<br>规则:参数(字符串)中存在与正则匹配的子串的情况下返回true,否则false</li>
</ol>
<ol>
<li>compile()</li>
</ol>
<p>String对象:</p>
<p>实例方法:</p>
<ol>
<li><p>match()<br>param1:String<br>将查找结果作为数组返回,每个元素为一个匹配的子串<br>不使用全局匹配的话，数组中只包含匹配子串，<br>返回数组包含三个属性:</p>
<ul>
<li>input 属性包含整个被查找的字符串</li>
<li>index包含在整个被查找字符串中匹配的子字符串的位置</li>
<li>lastIndex包含了最后一次匹配中最后一个字符的下一个文职</li>
</ul>
</li>
<li><p>replace()<br>param1: 正则表达式或者字符串<br>param2:替换字符串<br>用替换字符串替换与正则表达式匹配的子串</p>
</li>
</ol>
<ol>
<li><p>search()<br>param:<br>返回与正则表达式相匹配的子串首字母在母串中下标</p>
</li>
<li><p>split()<br>param:字符串或者正则<br>把字符串按照参数提供的规则分割为字符串数组</p>
</li>
</ol>
<p>反向引用:<br>包含分组的正则表达式在被与正则有关的方法调用后，每个分组所匹配的子串保存在RegExp对象的$n属性中，称为反向引用</p>
<p>可以通过RegExp.$n来在程序中调用，<br>也可以通过\n在正则表达式中使用</p>
<p>对于replace方法,反向引用可以在替换字符串中使用</p>
<p>str.replace(reg,’12’); //1 2 分别表示分组1和2</p>
<h3 id="正则表达式相关知识"><a href="#正则表达式相关知识" class="headerlink" title="正则表达式相关知识"></a>正则表达式相关知识</h3><p>限定符(设置匹配字符串数量)</p>
<ul>
<li>*匹配0到多个</li>
<li>+匹配1到多个</li>
<li>? 匹配0或1个</li>
<li>{n} 匹配n个</li>
<li>{n,}至少匹配n个</li>
<li>{n,m} 匹配n到m个</li>
</ul>
<p>字符类：设置字符集合来匹配指定范围内的字符</p>
<p> 例:  [a-z0-9A-Z]  匹配所有单个英文字母和数字</p>
<p>分支条件:满足任意一种规则,即退出当前分组 </p>
<p>子表达式(分组):<br>    例: (123)  为一个分组，匹配时看作一个整体</p>
<p>反义：</p>
<ul>
<li>\W 匹配任意不是字母数字下划线的字符</li>
<li>\S 匹配任意不是空白符的字符</li>
<li>\D 匹配任意非数字的字符</li>
<li>\B 匹配非单词边界</li>
<li>[^x] 匹配除x以外的任意字符</li>
<li>[^abcd] 匹配除abcd以外的任意字符</li>
</ul>
<p>后向引用:小括号指定的子表达式当被文本匹配，可以对匹配的文本进行处理,<br>默认情况下，每个分组自动拥有一个组号，以分组左括号为标志，按照出现顺序从1开始计数。<strong>用于重复搜索之前某个分组匹配的文本</strong></p>
<ul>
<li>(pattern): 捕获括号，用于获取匹配到的字符串，然后用于后续处理</li>
<li>(?:pattern):非捕获分组，匹配到的子串无法通过结果数组的下标进行访问</li>
<li>引用捕获到的分组，应使用\num方法，其中num表示对应捕获分组的编号</li>
<li>(?=pattern)：正向预查，在任何匹配pattern，非捕获匹配，断言自身出现的位置后面能匹配表达式exp</li>
<li>(?!pattern): 负向预查，非捕获匹配</li>
</ul>
<p>/^([a-z])\1$/  : 匹配连续的两个相同小写字母<br>在被替换的字符串中引用捕获分组，应使用$num记法</p>
<p>零宽断言:</p>
<p>零宽度正预测先行断言: 表示获取出现在设定的正则所匹配的字符串之前的字符串<br>例：(?=exp)  用来获取匹配exp的子串前面的字符串</p>
<p>贪婪:正则表达式通常匹配尽可能多的字符<br>懒惰匹配:在限定符后面加上<strong>?</strong>即可匹配尽量少的字符</p>
<ul>
<li>*？匹配任意次，尽可能少</li>
<li>+? 匹配1至多次，尽可能少</li>
<li>?? 匹配0或1次，尽可能少</li>
<li>{n,m} 匹配n到m次，尽可能少</li>
<li>{n,} 匹配至少n次，尽可能少</li>
</ul>
<p>优先级(由高到低)：</p>
<ul>
<li>转义符</li>
<li>括号</li>
<li>限定符</li>
<li>位置和顺序</li>
<li>| </li>
</ul>
<p>标志：</p>
<ul>
<li>i (ignoreCase)，忽略大小写</li>
<li>m (Multiline),多行匹配</li>
<li>g global 全局匹配</li>
</ul>
<h3 id="trim问题解析"><a href="#trim问题解析" class="headerlink" title="trim问题解析:"></a>trim问题解析:</h3><h4 id="正则表达式方法"><a href="#正则表达式方法" class="headerlink" title="正则表达式方法:"></a>正则表达式方法:</h4><p>ECMAscript5已经加入trim方法，从<a href="http://caniuse.com/#search=trim" target="_blank" rel="external">Can i use</a>网站来看，IE9以及Android4.3并不完全支持，所以自己写一个trim方法还是很有必要的。但如果浏览器支持的话，原生trim方法由于经过优化一般来说比自己实现的方法都要快。</p>
<p>方法1：</p>
<pre><code>    String.prototype.trim = function(){
    return this.replace(/^\s+/,&apos;&apos;).replace(/\s+$/,&apos;&apos;);
};
</code></pre><p>首尾分别用一个正则匹配。处理长字符串简单快速</p>
<p>针对浏览器的优化:</p>
<pre><code>消除末尾空白的正则改写为 /\s\s*/有助于提高在Firefox中的处理速度(Firefox对以不包含量词的字符为开始的正则表达式提供了优化)
</code></pre><p>方法2：</p>
<pre><code>String.prototype.trim2 = function(){
    return this.replace(/^\s+|\s+$/g,&apos;&apos;);
};
</code></pre><p>分支条件代替两次简单的正则匹配替换(若不添加g标志，只会匹配首尾空白中的一种)<br>执行情况:匹配包含首尾空白的字符串时会匹配两次，而由于有两个分支，所以对于每个待匹配的字符串都需要尝试两次.</p>
<p>方法3:</p>
<pre><code>String.prototype.trim3 = function(){
    return this.replace(/^\s*([\s\S]*?)\s*$/,&apos;$1&apos;)
};
</code></pre><p>方法介绍:<br>通过设置懒惰匹配分组使得，分组匹配从第一个非空白符开始直到最后一个非空白符,然后用捕获的该分组替换原始字符串.<br>性能:由于懒惰匹配的原因，容易存在回溯，在旧的浏览器中性能较差。</p>
<p>方法4(消除可能出现的回溯):</p>
<pre><code>String.prototype.trim4 = function(){
    return this.replace(/^\s*([\s\S]*\S)?\s*$/,&apos;$1&apos;)
};
</code></pre><p>方法介绍:<br>通过设置分组中最后一个匹配字符必须是非空白符来阻止分组的贪婪匹配导致匹配到末尾空白.<br>性能:<br>优于2,3,但在Firefox和Opera 9 中速度慢，导致性能略差于方法1.</p>
<p>方法5:</p>
<pre><code>String.prototype.trim5 = function(){
    return this.replace(/^\s*(\S*(\s+\S+)*)\s*$/,&apos;$1&apos;);
};
</code></pre><p>方法介绍:<br>显示设置分组1的前一个字符和末尾后的一个字符为空白符<br>性能:<br>速度最慢的一个，修改内部分组可以提高效率.</p>
<p>不使用正则表达式方法:</p>
<pre><code>    String.prototype.new_trim = function () {
    var start = 0, end = this.length - 1 ,
        ws = &quot;\n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f&quot; 
                + &quot;\u205f\u3000\ufeff&quot;;    //空白符字符串
    while(ws.indexOf(this.charAt(start)) &gt; -1) {  //字符串指定位置字符在空白符字符串中是否存在,存在的话表示start所在位置为空白符
        start++;
    }
    while(end &gt; start &amp;&amp; ws.indexOf(this.charAt(end)) &gt; -1 ){   //end位置要在start后面，否则待处理字符串全部为空白符组成
        end--;
    }
    return this.slice(start,end + 1); //slice方法中获取到的子串末尾下标为参数2减一
};
</code></pre><p>正则和非正则方法比较:</p>
<p>正则匹配为从前往后，而非正则方法可以通过下标直接访问，使得非正则方法匹配末尾时速度远快于正则方法.<br>但非正则方法由于需要循环遍历比较空白字符串，所以当存在首尾大段空白时，速度优势会降低.</p>
<p>混合解决方案:</p>
<pre><code>String.prototype.hybird_trim = function () {
    var str = this.replace(/^\s+/,&apos;&apos;),  //消除开头空白
        end = str.length - 1 ,
        ws  = /\s/;
    while(ws.test(str.charAt(end))){   //由循环比较空白字符串变为test正则，提高效率
        end--;
    }
    return str.slice(0,end+1); 
};
</code></pre><p>总结: 正则方法中字符串总长度对于性能的影响大于首尾空白的长度；而非正则的方法从末尾反向查找，与待处理字符串长度无关，但空白长度决定循环次数。</p>
<p>结论：混合方案在处理长字符串时速度快，但代码来说长一些，而正则中第一种方法性能表现均衡</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-JS复习知识点" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/21/JS复习知识点/" class="article-date">
  	<time datetime="2016-09-21T00:02:07.476Z" itemprop="datePublished">2016-09-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>null 转化为 数字 为 0，转化为 布尔 为 false undefined 转化为 数字 为 NaN, 转化为 布尔 为 false</p>
</li>
<li><p>声明变量:</p>
<ol>
<li>var</li>
<li>直接赋值，此时变量为全局变量</li>
<li>let 变量在块级作用域有效</li>
</ol>
</li>
<li><p>JS为Unicode 编码</p>
</li>
<li><p>变量声明提升:变量声明提升到函数块开头，即时先于声明语句访问，变量仍存在，但是变量初始化不提升，所以变量值为undefined</p>
</li>
<li><p>函数声明提升：提升函数声明，不提升函数表达式</p>
</li>
<li><p>在函数内部，若函数名，形参，局部变量相同。</p>
<ol>
<li>先访问局部变量</li>
<li>形参</li>
<li>函数名</li>
</ol>
</li>
<li><p>全局变量实际为全局对象的属性， 网页中全局对象为window</p>
</li>
<li><p>声明常量：const，常量只读，必须在初始化时便初始化，此后不能赋值 但是常量若为对象时，内部属性是可以修改的</p>
</li>
<li><p>6种基本数据类型：</p>
<ul>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>null</li>
<li>undefined</li>
<li>Symbol 实例唯一且不可修改</li>
</ul>
</li>
<li><p>数据类型转换</p>
<ul>
<li>加号两边若为字符串和数字时，数字转化为字符串</li>
<li><p>字符串(可以表示数字)转化为数字：</p>
</li>
<li><p>parseInt(string，radix)函数,以第二参数作为字符串表示数字的基数，返回10进制整数，丢失小数部分,遇到非数字就断开，以之前获取到的数字作为字符串表示数字</p>
</li>
<li>parseFloat()函数</li>
<li>单目加法 +”123”</li>
</ul>
</li>
<li><p>字面量(不可修改)：</p>
<ul>
<li>数组字面量 [1,2,3] a = [1,,3] (其中 a[1] = undefined )</li>
<li>布尔字面量</li>
<li>浮点字面量</li>
<li>整数</li>
<li>对象字面量</li>
<li>正则表达式RegExp</li>
</ul>
</li>
<li><p>同一作用域中，不能用同函数名或者变量名相同的字符串来命名常量。</p>
</li>
<li><p>布尔对象值为false(包装对象)转化为布尔值时为 true</p>
</li>
<li><p>for of statement 遍历元素的值</p>
</li>
<li><p>数组推导式 ： [for(year in years ) if(year &gt; 123) year ] 等价于： years.map(function(i) { return i &gt; 3; })</p>
</li>
<li><p>void function(){} 为函数表达式 , 等同 (function() {})</p>
</li>
<li><p>void运算符用来表示不返回值，同时可以将函数识别为函数表达式。 例: void(foo()) 浏览器会对冒号后的表达式求值，然后将求值显示到页面 <a href="javascript:void(0);" target="_blank" rel="external"> <a href="javascript:;" target="_blank" rel="external"> 上述链接点击后不会有任何效果。 根据void运算符识别为函数表达式的效果，可以在href属性中插入函数，此时会调用该函数</a></a></p>
</li>
<li><p>typeof返回字符串，对null的操作返回”object”，symbol返回”symbol”，NaN返回”number”</p>
</li>
<li><p>包装对象的返回值是其对应原始类型 例：typeof String(‘123’) 返回值 为 “string” typeof undefined 返回值 为 “undefined” typeof new String(‘123’)返回值 为 “object” new表示构造函数生成对象</p>
</li>
<li><p>typeof /a/ 返回值 为 ‘object’</p>
</li>
<li><p>~按位非， !逻辑非</p>
</li>
<li><p>&amp; | ^ 按位 与 或 非 &amp;&amp; || ^^ 逻辑 与 或 非</p>
</li>
<li><p>逗号运算符 , 可以将多个表达式放置在同一句中，并且返回最后一个表达式的结果</p>
</li>
<li><p>>> 算数右移，根据数值正负，用0或1来补充 &gt;&gt;&gt; 无符号右移</p>
</li>
<li>位逻辑运算符操作中，会将操作数(数字)转化为32位整数</li>
<li><p>函数调用自身方法：</p>
<ol>
<li>使用函数名</li>
<li>arguments.callee调用正在调用的函数</li>
</ol>
</li>
<li><p>闭包保存它可见作用于中所有参数和变量</p>
</li>
<li><p>每个函数的作用域通过函数的嵌套，从而产生作用域链</p>
</li>
<li><p>命名冲突时，更紧的作用域有更高的优先级</p>
</li>
<li><p>从ECMAscript6开始，函数参数分为两类:</p>
<ul>
<li>默认参数</li>
<li>剩余参数</li>
</ul>
</li>
<li>一般情况下，参数默认值为undefined，默认参数值的设置直接在函数声明中给形参赋值即可</li>
<li>将不确定数量的参数表示为数组</li>
<li>箭头函数均为匿名函数,箭头函数中的this值等同外部函数的this值</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-HTML标签分类" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/21/HTML标签分类/" class="article-date">
  	<time datetime="2016-09-21T00:02:07.445Z" itemprop="datePublished">2016-09-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="从元素嵌套到HTML标签分类"><a href="#从元素嵌套到HTML标签分类" class="headerlink" title="从元素嵌套到HTML标签分类"></a>从元素嵌套到HTML标签分类</h3><p>HTML4的元素分类：</p>
<p>从类别来讲来讲，对于HTML4，<br>行内(inline-level)元素不能嵌套(包裹)块级(block-level)元素。<br>嵌套规则详见 文章  </p>
<blockquote>
<p><a href="http://www.cs.tut.fi/~jkorpela/html/strict.html" target="_blank" rel="external">Allowed nesting of elements in HTML 4 Strict (and XHTML 1.0 Strict)</a></p>
</blockquote>
<p>实际来讲，块级元素、行内元素的定义均来自CSS2.1,<br>描述翻译如下：</p>
<blockquote>
<p>块级元素：<br>块级元素为在文档中视觉表现为块(例如：段落p标签),display属性为block、list-item、table时，即使得元素成为块级(block-level)。<br>行内元素:<br>行内元素为在文档中不生成新的内容块。行内元素共同组成完整的line (例如: em标签、img标签),display属性为inline、inline-block、inline-table。行内元素生成行内框，行内框用于组成行内格式上下文</p>
</blockquote>
<p>HTML5的元素模型分类:</p>
<p>Flow content(流元素):<br>流元素通常包含文本或者嵌入内容(embed、canvas、iframe等)，<br>除此之外，还有其他元素在特殊情况下满足：</p>
<ul>
<li>当area是map的子孙节点时</li>
<li>当link标签包含itemprop属性(表示元素的数据项属性,一般来说元素包含的文本即为数据项属性值)时</li>
<li>当meta标签包含itemprop属性(对meta而言，添加itemprop属性类同content，但包含的内容不是页面内容一部分,与content属性相似)</li>
<li>当style(内嵌样式表)包含scoped属性时(只对当前元素父元素。)</li>
</ul>
<p>Heading content(标题元素):<br>用来定义章节(section)的title，无论是用章节元素(Section content)显式标记或者是标题内容隐式定义<br>包括：h1-h6、hgroup</p>
<p>Section content(章节元素):<br>用于定义header(头部标签)和footer(页脚标签)范围<br>包括：article、aside、nav、section</p>
<p>Phrasing content(语法元素，段落元素):<br>段落元素定义了它包含的文本和标记<br>包括：</p>
<p>Embedded content(内嵌元素):<br>引入其他资源或者从其他标记语言或命名空间插入内容的元素。<br>包括：<br>audio、canvas、embed、iframe、img、math、object、svg、video</p>
<p>Interactive content(交互元素):<br>设计用于用户交互的元素，包括：a、button、detail、embed、iframe、keygen、label、select、textarea<br>特定情况下，一些元素属于交互元素：</p>
<ul>
<li>audio 包括controls属性</li>
<li>img 包括usemap属性</li>
<li>input type属性不为hidden</li>
<li>menu type属性为toolbar</li>
<li>object 包括usemap属性</li>
<li>video 包括controls属性</li>
</ul>
<p>Metadata content(元数据元素)：<br>用于说明或修改文档的表现，设置link到其他文档或者传递其他out of band信息</p>
<p>Palpable content(可感知元素):<br>当内容非空或者隐藏的时候。元素模型是流元素或者段落元素.</p>
<p>Form-associated content(表格相关元素):</p>
<p>包含以下子类别：<br>listed：   元素包含在form.elements的类数组中<br>labelable：可以同label联系起来<br>submittable：组成表单提交的数据<br>resettable：表单rest时会受到影响</p>
<p>不同元素可以属于多种元素模型，<br>对于元素上下文也有一定要求<br>允许的子元素模型也有要求</p>
<p>那么，嵌套错误会怎么样？</p>
<blockquote>
<p>浏览器尝试修复错误，因为浏览器对于HTML解析引擎包含容错机制</p>
</blockquote>
<p>但是有些错误浏览器无法修复，这便是</p>
<p>严格嵌套约束</p>
<p>相对宽松的，浏览器能够修复的错误，便是语义嵌套约束</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-socket-io学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/19/socket-io学习/" class="article-date">
  	<time datetime="2016-07-19T09:41:01.000Z" itemprop="datePublished">2016-07-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/19/socket-io学习/">socket.io学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>传统方法实现即时数据交互需要通过轮询，设置时间戳，导致效率低下</p>
<p>Socket成为即时聊天系统的解决办法，提供双向沟通频道，介于client和server之间。<br>Server可以传递数据给client,无论何时你传递数据给Server，Server都可以将它传递给其他连接的client。</p>
<p>Socket.IO由以下两部分组成:</p>
<ul>
<li>集成了Node.js中http模块(服务器模块)的Server : socket.io</li>
<li>在服务器端加载的客户端库 : socket.io-client</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-background复合属性解析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/18/background复合属性解析/" class="article-date">
  	<time datetime="2016-07-18T10:22:53.000Z" itemprop="datePublished">2016-07-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/18/background复合属性解析/">background复合属性解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>background:</p>
<ol>
<li>background-image<br> 为元素指定一个或多个背景,可以是图片也可以是CSS实现的渐变效果</li>
</ol>
<blockquote>
<p>由于元素可以有多个背景，所有后面有些属性的会存在多组属性值(逗号隔开)，分别对应不同的背景图片</p>
</blockquote>
<ol>
<li>background-position<br> 指定背景的初始位置，相对于background-origin指定的区域.<br> 属性值:<br> top/left/right/bottom/center/%/绝对长度<br> 属性值为两个方向(上下 左右)的组合。 </li>
<li>background-size<br> 设置背景大小<br> 属性值：%/绝对单位/cover/contain<br> 百分比相对于background-origin决定的<strong>背景区域</strong>大小来决定背景图片的大小。<br> cover表示背景区域被背景图片<strong>完全覆盖</strong>。可能导致背景图片部分不可见。同时这导致。<br> contain表示背景区域需要<strong>包括整个</strong>背景图片，所以背景区域可能存在空白。<br> 以上都建立在不对背景图片进行修改比例的变换基础上。</li>
</ol>
<blockquote>
<p>位图一定有固有尺寸与固有比例，矢量图可能两者都有，也可能只有一个。渐变视为只有固有尺寸或者只有固有比例的图片。</p>
</blockquote>
<ol>
<li><p>background-repeat<br> 指定背景图片是否以指定方式重复出现.<br> 单属性值: repeat-x/repeat-y/repeat/space/round/no-repeat<br> 双属性值(水平 垂直):属性取值同上，不过一组为两个值，分别指定不同方向的重复情况</p>
<p> 效果区别:</p>
<p> repeat ： 有可能存在元素边缘位置背景图片被裁剪<br> space :  第一个和最后一个图像会被固定在元素(element)的相应的边上, 同时, 重复导致剩余的空白会均匀地分布在图像之间. background-position属性会被忽视。<br> 当背景图大于元素大小时，出现裁剪情况。<br> round: 当背景区域大小分配n个背景图片有多余位置但不够放置下一个背景图片时，将n个背景图片伸展。直到下一个背景图片有足够空间放置时，压缩之前的背景图片用于放置新的背景图片。</p>
</li>
<li><p>background-origin<br> 背景的background-image原点相对于元素的位置<br> 属性值：<br> border-box:背景延伸到外边距的边框位置，在外边界边框位置，背景被覆盖在边框下面<br> padding-box:背景绘制在外边距内部。<br> content-box: 背景绘制在内边距内部(内容区).</p>
</li>
<li><p>background-clip<br> 指定元素背景延伸的边界<br> 属性值:<br> border-box 延伸到边框外边界(但是被边框所覆盖)<br> padding-box 延伸到内边距外边界(即边框内部)<br> content-box 延伸到内容区(即内边框内部)</p>
</li>
<li><p>background-attachment</p>
<p> 指定元素背景在视口中固定还是随元素块移动<br> 属性值:<br> fixed : 背景相对于视口固定，不随元素的滚动而滚动<br> scroll : 背景相对于元素固定,即相对位置不变<br> local : 相对于元素本身固定，但是如果元素本身可以滚动的话，背景会相对于元素内容滚动</p>
<p> local和fixed关系类似于absolute和fixed关系</p>
</li>
<li><p>backgrounf-color<br> 当背景颜色未生效时，显示的元素背景颜色</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-浮动与定位" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/14/浮动与定位/" class="article-date">
  	<time datetime="2016-06-14T12:35:00.000Z" itemprop="datePublished">2016-06-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/14/浮动与定位/">浮动和定位</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="浮动和定位"><a href="#浮动和定位" class="headerlink" title="浮动和定位"></a>浮动和定位</h3><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>浮动，将元素从文档的正常流中删除，但仍影响布局。</p>
<p>元素浮动时，其他内容会”环绕”该元素。</p>
<p>浮动元素周围的外边距不合并。</p>
<ul>
<li>行内框与浮动元素重叠时，边框、背景和内容都在浮动元素 <strong>之上</strong>显示。</li>
<li>块框与浮动元素重叠时，边框和背景在浮动元素 <strong>之下</strong>显示，内容在浮动元素 <strong>之上</strong></li>
</ul>
<p>float:none 阻止元素浮动</p>
<p>浮动行内非替换元素时，需要设置width,否则元素宽度趋向于0</p>
<p>浮动元素包含块时其最近块级祖先元素.</p>
<p>浮动元素自动生成为块级框？？display设置无效</p>
<p>浮动元素之间不会彼此覆盖或者重叠</p>
<p>如果浮动元素之前还有一个元素，浮动元素顶部不能超过该元素生成框的任何行框，<br>即浮动元素低于前一个元素的最低行框</p>
<p>浮动元素自动生成块级框，即只能占据整个行框的一个元素框。当当前行框中存在任何其他元素(文档中之前出现的元素)占据空间时，浮动元素会到下一行进行浮动。<br> 若浮动图片处于一个段落中，则浮动图片最高点只能放在图片所在行框的顶部.<br> <a href="http://jsbin.com/yufoziqavu/1/edit?html,output" target="_blank" rel="external">实例</a></p>
<p>清除元素(设置clear属性的元素)为放置被float元素覆盖，会落在float元素的下边，实际上和设置margin使得元素内容恰好在float元素下面一样。所以给清除元素添加 <strong>上外边距</strong>没有意义。</p>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>position:</p>
<p>static:<br>行内元素生成一个或多个行框<br>块级元素则生成一个矩形框</p>
<p>relative:</p>
<p>相对未设置浮动和定位属性前的位置进行偏移，原本占据空间保留</p>
<p>absolute:</p>
<p>脱离正常流，相对于其包含块定位。<br>元素之前在正常流中占据的空间关闭，定位元素生成一个块级框(只能从一个无元素占据空间的行框开始占据空间)</p>
<p>fixed：</p>
<p>类似absolute，但包含块为视窗，相对视窗定位。</p>
<p>包含块(针对定位):</p>
<p>若position值为relative或static，则包含块为最近的块级框、表单元格、行内快祖先框的内容区构成。</p>
<p>position值为absolute，则包含块为最近的position为除static以外的其他祖先元素：</p>
<pre><code>若祖先元素为块级框，则为其内边距边界(以边框作为边界)
            行内框，则为其内容边界
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-对象属性的内部特性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/13/对象属性的内部特性/" class="article-date">
  	<time datetime="2016-06-13T03:26:32.000Z" itemprop="datePublished">2016-06-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/13/对象属性的内部特性/">对象属性的内部特性</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>属性分类:</p>
<ol>
<li>数据属性<br> 包含特性:<br> [[Configurable]]: 属性是否可以删除，属性的特性是否可以被修改,属性分类是否可以变为访问器属性<br> [[Enumberable]]:属性是否可枚举,即for in 是否返回该属性<br> [[Writable]]:属性值是否可修改<br> [[Value]]: 属性值<br>通过Object.defineProperty()方法(ES5引入)</li>
<li>访问器属性</li>
</ol>
<p>访问器属性不包含数据值，包含getter和setter函数，读取访问器属性时，调用getter函数，写入时，调用setter函数<br>    包含特性:<br>    [[Configurable]]: 属性是否可以删除，属性的特性是否可以被修改,属性分类是否可以变为数据属性<br>    [[Enumberable]]:属性是否可枚举,即for in 是否返回该属性<br>    [[Get]]:读取属性时调用的函数<br>    [[Set]]:写入属性时调用的函数<br>同样可以通过Object.defineProperty()方法(ES5引入)<br>IE8及其以下版本使用<strong>defineGetter</strong>和__defineSetter设置get和set特性</p>
<p>不支持Object.defineProperty()方法的浏览器中不能修改Configurable和Writable特性</p>
<p>定义多个属性及其特性使用Object.defineProperties()方法<br>读取给定属性的特性Object.getOwnPropertyDescriptor()方法(ES5引入)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-视觉格式化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/12/视觉格式化/" class="article-date">
  	<time datetime="2016-06-12T02:05:24.000Z" itemprop="datePublished">2016-06-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/12/视觉格式化/">视觉格式化模型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="视觉格式化模型"><a href="#视觉格式化模型" class="headerlink" title="视觉格式化模型"></a>视觉格式化模型</h3><h4 id="text-align-适用于块级元素"><a href="#text-align-适用于块级元素" class="headerlink" title="text-align:适用于块级元素"></a>text-align:适用于块级元素</h4><p>块级元素和行内元素是由HTML文档标准决定的，display中的block和inline之类则和html标准定义的块级元素和行内元素的 <strong>表现</strong>类似，但是并不相同，即修改display属性可以使得行内元素/块级元素 表现得类似 块级元素/行内元素，但标签实质不变，不能因为修改display属性就可以行内元素嵌套块级元素(不恰当,但能表述问题)</p>
<p>width和height不能应用于行内非替换元素。</p>
<p>外边距，内边距为百分比时，是指相对于父元素的width计算的</p>
<p>默认边框为元素前景色(文本字体颜色),若无文本(img标签)，则为父元素的文本颜色.</p>
<p>元素背景延伸到边框边界，即背景是元素内容、内边距、边框共同的背景<br><a href="http://jsbin.com/boyuga/2/edit?html,output" target="_blank" rel="external">实例</a></p>
<h3 id="块级元素格式化"><a href="#块级元素格式化" class="headerlink" title="块级元素格式化"></a>块级元素格式化</h3><h4 id="水平格式化："><a href="#水平格式化：" class="headerlink" title="水平格式化："></a>水平格式化：</h4><p>包含块：最近的块级祖先框、表单元格或行内块祖先框的 <strong>内容边界</strong>.</p>
<p>元素框：所有元素都会生成一个矩形框, = 内容边界 + 边框 + 外边距</p>
<h4 id="元素框宽度和父元素width相同"><a href="#元素框宽度和父元素width相同" class="headerlink" title="元素框宽度和父元素width相同."></a>元素框宽度和父元素width相同.</h4><p>border、padding不能为负</p>
<p>width、magin-left和margin-right取值可以为auto:</p>
<ol>
<li><p>三者中之一设置为auto，为使其满足元素框宽度等于父元素width，则将auto强制变为所需长度</p>
</li>
<li><p>三者全为定值(过分受限)，强制将margin-right设置为auto，用来填补剩余距离</p>
</li>
<li><p>两外边距显式设置，width为auto，则将width设置为定值填补剩余距离</p>
</li>
<li><p>三者中两者auto：</p>
<ol>
<li>两外边距auto，则设置为相同长度，使得元素框在父元素中居中</li>
<li>某个外边距和widt为auto，设置为auto的外边距变为0</li>
</ol>
</li>
<li><p>三者全为auto，则将外边距设置为0，width默认auto(尽可能宽)</p>
</li>
</ol>
<p>边框宽度只能为长度，若设置了border-style，边框宽度默认为medium</p>
<p>替换元素：<br>    width为auto(默认值)，则元素框宽度 = 内容固有宽度<br>    width设置长度值，则元素框宽度 = 显式设置的宽度</p>
<blockquote>
<p>替换元素，若height或者width只设置其中之一时，另外一个未设置的属性等比例变化</p>
</blockquote>
<h4 id="垂直格式化"><a href="#垂直格式化" class="headerlink" title="垂直格式化"></a>垂直格式化</h4><p>设置高度 &gt; 内容所需占用的高度 ， 内容与边框之间存在空隙，类似含有padding的效果</p>
<p>设置高度 &lt; 内容所需占用的高度 ， 根据overflow的设置来显示内容</p>
<p>若margin-top或margin-bottom设置为auto，自动变为0</p>
<p>负外边距合并:</p>
<p>两元素外边距均为负： 取绝对值大的负外边距作为两元素之间外边距.<br>          一正一负:  正负作差为实际边距<br>若两元素外边距合并后值小于0会发生覆盖，而根据浏览器按照文档先后顺序渲染的原则，后面的元素的背景色有可能会覆盖之前元素的背景色.</p>
<p>list-style-position:可以将列表的标志放置在li内部或者外部，从而使得li表现为块级元素或者行内元素</p>
<h3 id="行内元素格式化："><a href="#行内元素格式化：" class="headerlink" title="行内元素格式化："></a>行内元素格式化：</h3><h4 id="line-height-可继承"><a href="#line-height-可继承" class="headerlink" title="line-height:可继承"></a>line-height:可继承</h4><p>对块级元素添加line-height属性时，实际应用到块级元素内部的各文本行(均可看作行内元素)，块级元素本身不受影响</p>
<p>行内只包含非替换元素时，如何构造行框:</p>
<ol>
<li>对于行内非替换元素或者匿名文本,font-size决定 <strong>内容区</strong>的高度</li>
<li>获得line-height高度,通过与font-size作差，差除以2，获得行间距,其中line-height决定 <strong>行内框</strong>高度大小</li>
</ol>
<p>通过行内框，决定整个行框的高度。见行框定义</p>
<h4 id="文本按照基线对齐"><a href="#文本按照基线对齐" class="headerlink" title="文本按照基线对齐"></a>文本按照基线对齐</h4><p>vertical-align设置为数值时，会将元素上移数值大小高度，同时使得行框高度也升高<br>其他值:<br>top: 元素行内框顶端与包含该元素的行框顶端对齐<br>bottom：                          行框底端对齐<br>text-top: 元素行内框顶端和父元素内容区顶端对齐<br>text-bottom:                    内容区底端对齐<br>middle: 元素行内框垂直中点与父元素基线上0.5ex处一点对齐<br>super：元素内容区和行内框上移<br>sub：                    下移<br>百分比: 相对同一元素line-height值</p>
<p>最佳实践: </p>
<blockquote>
<p>最好将line-height设置为一个原始数字值,此时该数字值为缩放因子(相对于自身font-size)，且可继承</p>
</blockquote>
<p><strong>行内元素的外边距，边框，内边距不影响行框的高度.</strong><br>但可以影响行框的宽度。</p>
<p>多行行内元素的边框和边距只在内容的开始和结尾包含产生左右效果，不会看作多个行内元素，在每行上面都生成左右边框。上下效果每行每个字符都存在.(负外边距的左右’拉近’效果也会存在，上下无拉近效果)</p>
<p>行内替换元素:<br>行内替换元素的高度(固有高度或者设置高度)会影响行框的高度.<br>此时行内替换元素的高度,指height，margin，border，padding的总和作为行框的高度，</p>
<p><strong>替换元素形成的元素框(非内容区)的底边和周围文字的基线水平.</strong></p>
<p>行内替换元素仍然会有line-height属性(显式设置或者继承自祖先元素)，行内替换元素通过该值确保垂直方向如何定位自身，尤其是设置vertical-align时，因为vertical-align的百分比数值相对于自身的line-height来计算的。</p>
<h4 id="匿名框"><a href="#匿名框" class="headerlink" title="匿名框:"></a>匿名框:</h4><p>匿名文本：未包含在 <strong>行内元素</strong>中的字符串，空格也是匿名文本的一部分。</p>
<p>em框： 字符框,font-size确定了各个em框的高度，实际显示的字形(glyph)和em框相比大小不一定相等</p>
<p>内容区: 对于非替换元素，元素中各字符的em框串在一起构成的框.替换元素，内容区就是元素固有大小加上外边距、边框或内边距</p>
<p>行间距：( font-size - line-height ) / 2 等于行间距。只应用于非替换元素</p>
<p>行内框：  内容区加上下行间距即等于行内框，对于非替换元素，line-height决定行内框大小，<br>对于替换元素，元素行内框等于内容区高度 + margin + padding + border，因为行间距不应用到替换元素.内容区即为替换元素高度.</p>
<p>行框：行框上边界位于最高行内框的上边界，底边位于最低行内框的下边界。</p>
<p>行内块元素:</p>
<p>行内块元素实际作为替换元素放在文本行内。即行内块元素底边默认位于文本行的基线上</p>
<p>display: run-in解析:</p>
<p>设置为run-in的元素若后跟块级元素框(无论是块级元素或是行内元素，表现类似于display值为block等块级样式的，杰克看作块级元素框),则该元素将成为后面块级元素框中的一个行内元素</p>
<p>当一个元素浮动之后，不会影响到块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，也就会出现包含框不会自动伸高来闭合浮动元素（“高度塌陷”现象）。</p>
<p>触发BFC(block formatting context):</p>
<ol>
<li>float除none以外的值</li>
<li>oveflow除visible以外的值(hidden,auto,scroll)</li>
<li>display值为块级框的(table-cell,table-caption,inline-block)</li>
<li>position值为absolute，fixed</li>
<li>fieldset元素(未规范)</li>
</ol>
<p>BFC功能：</p>
<ol>
<li>阻止块框外边距叠加</li>
<li>可以闭合浮动</li>
<li>浮动元素不会重叠</li>
</ol>
<p>清除浮动好的方法：</p>
<p>after伪元素闭合浮动</p>
<p>行内元素生成一个或多个行框<br>块级元素则生成一个矩形框</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-图片垂直居中" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/02/图片垂直居中/" class="article-date">
  	<time datetime="2016-06-02T14:24:49.000Z" itemprop="datePublished">2016-06-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/02/图片垂直居中/">图片垂直居中</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="图片垂直居中"><a href="#图片垂直居中" class="headerlink" title="图片垂直居中:"></a>图片垂直居中:</h4><pre><code>&lt;div id=&quot;imgBox&quot;&gt;
    &lt;img src=&quot;build/img/note_icon2.png&quot;&gt;
&lt;/div&gt;

    #imgBox{
        font-size:0;
        height:500px;
        background:red;
        text-align:center;   //用于图片水平居中
    }
    img{
        vertical-align: middle;
    }
    #imgBox:after{
        display:inline-block;
        content:&apos; &apos;;
        height:100%;
        width:0;
        vertical-align:middle;
    }
</code></pre><p>其中，容器高度确定(貌似父容器可以无高度),图片大小不固定。</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
    &lt;span id=&quot;imgBox&quot;&gt;
        &lt;img src=&quot;build/img/note_icon2.png&quot;&gt;
    &lt;/span&gt;
&lt;/div&gt;

    .container{
        height:500px;
    }
    #imgBox{
        font-size:0;
        height:500px;
        background:red;
        text-align: center;
    }
    img{
        vertical-align: middle;
    }
    #imgBox:after{
        display:inline-block;
        content:&apos; &apos;;
        height:100%;
        width:0;
        vertical-align:middle;
    }
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/经典布局样式/">经典布局样式</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-浏览器工作原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/29/浏览器工作原理/" class="article-date">
  	<time datetime="2016-05-29T12:01:59.000Z" itemprop="datePublished">2016-05-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/29/浏览器工作原理/">浏览器工作原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h3><p>本文主要是学习<br><a href="http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="external">浏览器的工作原理：新式网络浏览器幕后揭秘</a><br>时做的笔记，期间还参杂自己的一些理解。<br>水平有限，有错误地方欢迎指正。</p>
<h4 id="浏览器功能"><a href="#浏览器功能" class="headerlink" title="浏览器功能:"></a>浏览器功能:</h4><p>向服务器发出请求，获取以及发送一些网络资源，主要是html文档，当然还包括css，js，pdf,多媒体以及其他类型文件。资源位置由URI指定。</p>
<p>用户界面(基本元素):</p>
<ul>
<li>URL地址栏</li>
<li>前进后退</li>
<li>书签功能</li>
<li>刷新和停止刷新</li>
<li>主页按钮</li>
</ul>
<p>明天还有考试。。。。今天先不更了。。。</p>
<p>更新于 <strong>2016.5.29</strong></p>
<p>浏览器结构(非本文重点,直接引用)</p>
<p>用户界面</p>
<ul>
<li>包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li>
</ul>
<p>浏览器引擎 </p>
<ul>
<li>在用户界面和呈现引擎之间传送指令。</li>
</ul>
<p>呈现引擎 </p>
<ul>
<li>负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>
</ul>
<p>网络 </p>
<ul>
<li>用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li>
</ul>
<p>用户界面后端 </p>
<ul>
<li>用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li>
</ul>
<p>JavaScript 解释器</p>
<ul>
<li>用于解析和执行 JavaScript 代码。</li>
</ul>
<p>数据存储 </p>
<ul>
<li>这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li>
</ul>
<h4 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h4><p>用于显示浏览器请求的内容，默认可以显示html，css以及图片，通过插件等方式可以支持其他格式文件显示。</p>
<p>主要有以下几种渲染引擎(内核)：</p>
<ul>
<li>Trident(IE使用，Edge新内核为EdgeHTML,具体内容<a href="https://www.zhihu.com/question/29985708" target="_blank" rel="external">如何评价 Microsoft Edge 浏览器？</a>)，JS内核分别为Jscript(IE8),Chakra(IE9+)</li>
<li>Gecko(Firefox使用)，js内核(最新)为OdinMonkey</li>
<li>Webkit(Chrome之旧内核,Safari内核),包含WebCore  (html?)排版引擎和JavaScriptCore js解析引擎，是苹果从KHTML内核衍生出来的内核，</li>
<li>Blink(Chrome和Opera的新内核),Chrome的JavaScript引擎为V8,WebCore排版引擎    </li>
<li>Presto(Opera旧内核)，不做介绍</li>
</ul>
<h4 id="内核工作流程："><a href="#内核工作流程：" class="headerlink" title="内核工作流程："></a>内核工作流程：</h4><ol>
<li>解析HTML构造DOM树：<br> 同时解析CSS文件及html中内嵌样式，相结合用于用于渲染树的构建</li>
<li>渲染树构建<br> 渲染树的节点为一个个包含样式属性的盒模型</li>
<li>页面布局<br> 为DOM树节点分配不同坐标</li>
<li>绘制页面(通过渲染树)</li>
</ol>
<p>上述过程并非线性同步，而是异步进行，即解析HTML同时进行渲染树构建以及页面布局绘制。这也导致了在这一过程中,JS对DOM的修改会导致重绘</p>
<p>Webkit和Gecko的工作流程有些不同：</p>
<p><img src="http://o7zpnvyhh.bkt.clouddn.com/geckoflow.jpg" alt="Webkit流程"></p>
<p>获取HTML文档，通过html编译器解析HTML文档为DOM树(html标签转化为DOM节点)，<br>与此同时，获取到样式表(包括内嵌和外链)并解析为样式规则。DOM树和样式规则<br>相连接共同作用生成渲染树，渲染树用于布局(这里渲染树和布局的作用是双向的?),浏览器通过生成好的渲染树进行绘制，从而将样式应用到html文档并展示出来。</p>
<p><img src="http://o7zpnvyhh.bkt.clouddn.com/webkitflow.png" alt="Gecko流程"></p>
<p>获取HTML文档，解析html文档为内容槽(用于连接html解析器和文档?)，内容槽转化为内容模型，内容槽同时通过css解析器转化为样式规则，样式规则和内容模型连接生成帧构造(框架树)，帧构造产生框架树(帧 === 框架)，用于重排(reflow)，之后通过绘制从而展现应用样式规则的html文档。</p>
<h3 id="详细介绍："><a href="#详细介绍：" class="headerlink" title="详细介绍："></a>详细介绍：</h3><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>HTML文档采用DTD格式，非上下文无关语法，所以无法通过常规解析器解析。<br>解析器解析HTML文档输出DOM树(由DOM元素和属性即节点构成的树结构)</p>
<h5 id="解析过程："><a href="#解析过程：" class="headerlink" title="解析过程："></a>解析过程：</h5><p><img src="http://o7zpnvyhh.bkt.clouddn.com/resolve.png" alt="解析过程"></p>
<ol>
<li>标记化:词法分析，输入内容拆分成多个标记，包括起始结束标记，属性名称和值</li>
<li>树构建，识别标记同时传递给树构造器，不断识别标记，并构建DOM树</li>
</ol>
<p>标记化算法：</p>
<p>通过状态机实现，不同状态下遇到不同字符，跳转到不同状态。过于复杂，不再赘述。</p>
<p>树构建算法：</p>
<p>将Document对象作为DOM树根节点，对DOM树不断进行修改。状态机分割的token传递过来后，通过树构建器将其添加到DOM树中，同时，通过堆栈对标记的闭合等问题进行检测。</p>
<p>解析完成后，DOM树构建完毕，页面变为交互状态(加载完成)，之后加载defer的脚本，对DOM树进行修改，完全完毕后，变为”完成”状态。<br>此时，加载事件将可被触发。</p>
<p>HTML5文档容错机制：</p>
<h4 id="更新于2016-6-1"><a href="#更新于2016-6-1" class="headerlink" title="更新于2016.6.1"></a>更新于2016.6.1</h4><h4 id="节日快乐"><a href="#节日快乐" class="headerlink" title="节日快乐"></a>节日快乐</h4><h4 id="CSS解析"><a href="#CSS解析" class="headerlink" title="CSS解析"></a>CSS解析</h4><p>CSS为上下文无关语法，所以可以通过常用解析器进行解析。</p>
<p>Webkit解析器:<br>使用Flex和Bison解析生成器，通过CSS语法规则自动创建解析器。<br>Bison创建自上而下的移位规约解析器。Firefox使用的是自己编写的自上而下的解析器。通过解析器将CSS文件解析为一个个StyleSheet对象，每个对象包含选择器和声明对象(CSS规则)。</p>
<p><img src="http://o7zpnvyhh.bkt.clouddn.com/resolvecss.png" alt="CSS解析过程"></p>
<h4 id="脚本和样式处理顺序"><a href="#脚本和样式处理顺序" class="headerlink" title="脚本和样式处理顺序"></a>脚本和样式处理顺序</h4><h5 id="脚本"><a href="#脚本" class="headerlink" title="脚本:"></a>脚本:</h5><p>同步解析，阻塞浏览器进程。如果是外链脚本，下载过程中会阻塞页面解析，等待脚本下载并执行,原因是脚本文件可能修改HTML文档结构，此时并行执行解析和执行脚本任务有可能会产生冲突，所以执行过程必须要阻塞浏览器进程(页面渲染和DOM树生成)。<br>现代浏览器现在也可以并行下载脚本文件，但是脚本的下载会阻塞其他资源的下载。并行执行问题仍然存在，所以脚本执行仍然会阻塞浏览器进程。<br>defer脚本会在DOM加载完成，onload事件触发前被执行，但是下载仍在解析到script标签时就开始。<br>async脚本异步执行脚本(多个脚本异步执行顺序不一定,onload事件前执行)，同样下载是立即下载<br>动态脚本会立即下载，执行，并且不阻塞浏览器进程。</p>
<h4 id="预解析"><a href="#预解析" class="headerlink" title="预解析:"></a>预解析:</h4><p>暂时未深入学习</p>
<h4 id="样式表"><a href="#样式表" class="headerlink" title="样式表:"></a>样式表:</h4><p>应用样式表不会修改DOM树，但是脚本有可能请求样式信息。<br>如果在样式表加载解析过程中，脚本试图获取样式信息就会获得错误信息。<br>所以不同浏览器采用了不同方案阻止这样的情况发生。<br>Firefox在样式表加载解析过程中，禁止脚本。而Webkit则会在尝试获取未加载的样式时，禁止该脚本。</p>
<h4 id="渲染树构建"><a href="#渲染树构建" class="headerlink" title="渲染树构建:"></a>渲染树构建:</h4><p>DOM树构建同时，渲染树也在进行构建，不同于DOM树的构建，渲染树的节点是根据显示顺序来添加的。</p>
<h4 id="渲染树和DOM树关系"><a href="#渲染树和DOM树关系" class="headerlink" title="渲染树和DOM树关系"></a>渲染树和DOM树关系</h4><p>DOM树中display:none的节点和非可视化节点(head等)不会添加到渲染树中，<br>DOM树中一个节点也可能对应多个可视化对象</p>
<blockquote>
<p>例如，“select”元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。<br>格式无效的 HTML。例如:根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 呈现器，以包裹 inline 元素。</p>
</blockquote>
<p>DOM树中节点位置可能和渲染树中对应节点位置不同。受float和position属性影响,在渲染树中原位上防止占位帧，真正所在位置才放置实际用于渲染的帧。</p>
<h4 id="构建呈现树的流程"><a href="#构建呈现树的流程" class="headerlink" title="构建呈现树的流程"></a>构建呈现树的流程</h4><p>待学习</p>
<h4 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h4><p>整合内嵌，行内，外链以及html标签自带属性(转化为对应CSS规则)，同时还有浏览器默认样式，用户自定义样式。<br>样式匹配(选择器匹配):从右向左匹配</p>
<h4 id="共享样式数据"><a href="#共享样式数据" class="headerlink" title="共享样式数据"></a>共享样式数据</h4><h4 id="Firefox规则树"><a href="#Firefox规则树" class="headerlink" title="Firefox规则树"></a>Firefox规则树</h4><p>Firefox中样式对象保存在类似样式上下文树的树结构中<br>Webkit则只单纯指向此类对象的应用样式。</p>
<p>样式上下文包含 <strong>端值</strong>,<br>需要对所有匹配规则按照正确顺序进行引用，规则树中祖先后代关系使得DOM节点之间可以共享规则。<br>底层节点拥有较高的优先级(与CSS规则层叠有关)<br>树中包含所有规则，<strong>只有当某个节点样式需要计算时才像规则树添加计算路径</strong></p>
<h4 id="结构划分"><a href="#结构划分" class="headerlink" title="结构划分"></a>结构划分</h4><p>样式上下文分割为多个结构。结构体中包含特定类别的样式信息。<br>结构中属性均为继承或者均为非继承。可继承属性若在当前节点无定义，则继承自父节点。不可继承属性未定义，则使用默认值。</p>
<h4 id="使用规则树计算样式上下文"><a href="#使用规则树计算样式上下文" class="headerlink" title="使用规则树计算样式上下文"></a>使用规则树计算样式上下文</h4><p>计算某个特定元素的样式上下文时，先计算规则树中对应路径。沿着路径应用规则，在新的样式上下文中填充结构。从路径中拥有</p>
<p>如果某个元素与其同级元素都指向同一个树节点，则他们会共享整个样式上下文。</p>
<h3 id="规则树构建未理解"><a href="#规则树构建未理解" class="headerlink" title="规则树构建未理解!!!"></a>规则树构建未理解!!!</h3><h4 id="对规则进行处理简化匹配"><a href="#对规则进行处理简化匹配" class="headerlink" title="对规则进行处理简化匹配"></a>对规则进行处理简化匹配</h4><p>样式表解析完毕后，根据 <strong>最右选择器</strong> 将CSS规则添加到多个哈希表中(ID、类、标记、通用)。<br>从哈希表中通过键值提取元素规则即可实现规则匹配。</p>
<h4 id="正确层叠顺序应用规则"><a href="#正确层叠顺序应用规则" class="headerlink" title="正确层叠顺序应用规则"></a>正确层叠顺序应用规则</h4><p>样式对象具有与每个可视化属性一一对应的属性。<br>未定义可继承属性可以继承祖先元素样式对象。非继承属性(reseth属性)应用默认值。</p>
<h4 id="样式表层叠顺序"><a href="#样式表层叠顺序" class="headerlink" title="样式表层叠顺序"></a>样式表层叠顺序</h4><ol>
<li>浏览器声明</li>
<li>用户普通声明</li>
<li>作者普通声明</li>
<li>作者重要声明</li>
<li>用户重要声明</li>
</ol>
<blockquote>
<p>重要声明： ！important</p>
</blockquote>
<h4 id="特异性-选择器优先级-：-待继续学习"><a href="#特异性-选择器优先级-：-待继续学习" class="headerlink" title="特异性(选择器优先级)： 待继续学习 "></a>特异性(选择器优先级)： <strong>待继续学习 </strong></h4><ol>
<li>行内样式(标签的style属性)</li>
<li>ID属性选择器</li>
<li>类选择器，其他选择器(属性选择器, + ~ 等等)</li>
<li>元素选择器和伪类选择器</li>
</ol>
<p>以上四种产生一个16进制四位数(谷歌似乎有修正)，作为改CSS规则集优先级，在对元素应用样式规则时进行比较。</p>
<h4 id="规则排序"><a href="#规则排序" class="headerlink" title="规则排序"></a>规则排序</h4><h4 id="渐进式处理"><a href="#渐进式处理" class="headerlink" title="渐进式处理"></a>渐进式处理</h4><p>Webkit通过一个标记来表示是否所有顶级样式表均已加载完毕，如果在attach过程中尚未加载完全，则使用占位符并在文档中标注，等加载完毕后重新计算。</p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>渲染树创建完毕后，并不包含位置和大小信息。通过布局(重排)来计算元素的位置大小。</p>
<p>HTML采用流的布局模型，所以大多数情况下一次遍历即可计算出文档布局大小。<br>坐标系相对于根框架建立，采用上左坐标。</p>
<h4 id="Dirty位系统"><a href="#Dirty位系统" class="headerlink" title="Dirty位系统"></a>Dirty位系统</h4><p>对某个元素呈现器发生变化做标记，<br>dirty表示当前元素呈现器变化<br>children are dirty表示子树中有元素呈现器变化</p>
<h4 id="全局布局和增量布局"><a href="#全局布局和增量布局" class="headerlink" title="全局布局和增量布局"></a>全局布局和增量布局</h4><p>全局布局： 触发了渲染树框架级别的布局变化<br>增量布局： 只对dirty呈现器进行布局。呈现器为dirty时异步触发增量布局。</p>
<h4 id="异步布局和同步布局"><a href="#异步布局和同步布局" class="headerlink" title="异步布局和同步布局"></a>异步布局和同步布局</h4><p>增量布局： 异步执行。将dirty呈现器的增量布局任务’reflow’命令加入队列，调度程序每次批量执行命令。</p>
<blockquote>
<p>请求样式信息(元素布局信息,例clientHeight)可同步触发增量布局。</p>
</blockquote>
<p>全局布局：同步触发</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>布局仅仅是大小调整或者呈现器的 <strong>位置</strong>改变而触发，则从缓存中获取呈现器大小，只计算呈现器位置。<br>有时渲染树中的子树变化时，不影响周围元素的布局。所以无需从根节点重新布局。</p>
<h4 id="布局处理"><a href="#布局处理" class="headerlink" title="布局处理"></a>布局处理</h4><p>布局处理模式：</p>
<ol>
<li>父呈现器设置自己的大小</li>
<li>父呈现器一次处理子呈现器：<ol>
<li>放置子呈现器</li>
<li>有必要的话，调用子呈现器的布局(例：dirty)，重新计算子呈现器布局</li>
</ol>
</li>
<li>父呈现器根据子呈现器累加高度(包括内外边距和边框，补白)确定自身高度</li>
<li>dirty位设置为false</li>
</ol>
<h4 id="宽度计算"><a href="#宽度计算" class="headerlink" title="宽度计算"></a>宽度计算</h4><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>如果呈现器在布局过程中需要换行，则立即停止布局，告知祖先需要换行，父元素创建额外呈现器并进行布局。</p>
<h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>遍历渲染树，调用呈现器的paint方法并显示在屏幕上。</p>
<h4 id="全局绘制和增量绘制"><a href="#全局绘制和增量绘制" class="headerlink" title="全局绘制和增量绘制"></a>全局绘制和增量绘制</h4><p>部分呈现器变化但不影响整个树，则将其绘制结果(在屏幕上的显示区域)设置为无效，并设置为’dirty区域’。浏览器合并多个’dirty区域’后调用paint。</p>
<h4 id="绘制顺序"><a href="#绘制顺序" class="headerlink" title="绘制顺序"></a>绘制顺序</h4><p>即元素进入堆栈样式上下文顺序。</p>
<ol>
<li>背景颜色</li>
<li>背景图片</li>
<li>边框</li>
<li>子代</li>
<li>轮廓</li>
</ol>
<h4 id="Webkit矩形存储"><a href="#Webkit矩形存储" class="headerlink" title="Webkit矩形存储"></a>Webkit矩形存储</h4><p>在重新绘制前，将旧矩形存储为位图，只绘制新旧图之间的差异</p>
<h4 id="动态变化"><a href="#动态变化" class="headerlink" title="动态变化"></a>动态变化</h4><h4 id="呈现引擎的线程"><a href="#呈现引擎的线程" class="headerlink" title="呈现引擎的线程"></a>呈现引擎的线程</h4><p>呈现引擎为单线程，Firefox和Safari中为浏览器主线程，而Chrome中，因为采用一个多核(一个标签页一个进程)，该线程为当前标签的主线程。</p>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>浏览器主线程为时间循环。是永远处于受理状态的一个无限循环，等待时间发生并处理</p>
<h4 id="CSS2可视化模型"><a href="#CSS2可视化模型" class="headerlink" title="CSS2可视化模型"></a>CSS2可视化模型</h4><h4 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h4><p>由内容，内边距，边框，外边距组成。<br>display属性则决定生成的框类型。</p>
<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><ol>
<li>无定位属性或默认定位属性</li>
<li>浮动</li>
<li>相对绝对固定定位</li>
</ol>
<p>框类型：</p>
<p>block类型：从上到下布局<br>inline类型：从左到右布局，包含块大小不足以放置下一个inline类型框时，放置到下一行开头，默认(尽量)从包含块顶部开始放置</p>
<h4 id="浮动："><a href="#浮动：" class="headerlink" title="浮动："></a>浮动：</h4><p>浮动框会移动到行的左边或者右边。会产生环绕效果。脱离普通流。</p>
<h4 id="绝对定位和固定定位"><a href="#绝对定位和固定定位" class="headerlink" title="绝对定位和固定定位"></a>绝对定位和固定定位</h4><p>脱离普通流。</p>
<p>绝对定位元素的位置相对于最近的定位元素(relative,absolute,fixed均可)<br>固定定位位置相对于视口。</p>
<h4 id="分层展示"><a href="#分层展示" class="headerlink" title="分层展示"></a>分层展示</h4><p>多个框分散在多个 <strong>堆栈上下文</strong>中,每个堆栈中，先绘制z轴中后面的元素，然后在顶部绘制前面的元素。重叠时，新绘制元素覆盖之前的元素。<br>具有z-index属性框形成本地堆栈。视口具有外部堆栈。<br>即首先看标签顺序，之后看z-index顺序，最后看是否为固定定位。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/浏览器工作原理/">浏览器工作原理</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 TalkLee
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>